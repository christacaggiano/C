#include <stdio.h>
#include <stdlib.h>
#include <Puzzle.h>
#include <Output.h>

//defined booleans for ease of coding 
#define False 0
#define True 1


//defines the puzzle board as a struct consisting of 
//a 2 dimensional array, a pointer to the previous board 
//and the direction/character moved from the previous
typedef struct puzzleBoard {
   char board [BoardHeight][BoardWidth];
   char * original;
   struct puzzleBoard *prev;
   int numRounds;
   int dir;
   char pieceMoved;
} *TypePuzzleBoard;

//creates a new puzzle board, takes in a position string 
TypePuzzleBoard newPuzzleBoard(char letters[BoardSize]) {
    TypePuzzleBoard b = (TypePuzzleBoard) malloc(sizeof(struct puzzleBoard));
    if (b==NULL) {printf("Malloc for a new puzzle board failed."); exit(1);}
    b->numRounds=0;
    b->prev = NULL;
    b->dir=-1;
    int i;
    int j;
    int position= 0;
    for (i=0; i<BoardHeight; i++){
    	for (j=0; j<BoardWidth; j++){
    		b->board[i][j] = letters[position];
    		position++;
    	}
    }
    b->original = letters;
    return b;

}

//function that takes in two puzzle board and compares them 
//to return whether or not the boards are equivalent 
int arePositionsEqual(TypePuzzleBoard b, TypePuzzleBoard b2){
	int i;
    int j;

	for (i=0; i<BoardHeight; i++){
    	for (j=0; j<BoardWidth; j++){
    		if (b->board[i][j]!=b2->board[i][j]){
    			return False;
    		}
    	}
    }
    return True;

}

// Modified from https://github.com/iamaaditya/C-tutorial/blob/master/List.c 
//creates a linked list of type puzzleBoard
typedef struct vbody {
   struct vbody *NEXT;
   TypePuzzleBoard board;
} *TypeVertex;

typedef TypeVertex TypeList;

//allocates memory for new vertex to linked list
TypeVertex NEWVERTEX() {
    TypeVertex p = (TypeVertex) malloc(sizeof(struct vbody));
    if (p==NULL) {printf("Malloc for a new vertex failed."); exit(1);}
    p->NEXT = NULL;
    return p;
}

// Modified from https://github.com/iamaaditya/C-tutorial/blob/master/List.c 
//inserts new vertex into the front of the linked list 
void INSERT(TypePuzzleBoard b, TypeList *L) {
    TypeVertex w = NEWVERTEX();
    w->board = b;
    w->NEXT = *L;
    *L = w;
}

TypeList X=NULL;

//computes how many items were in a linked list- 
//used for determining the bucket size in hashStats
int lengthOfLinkedList(TypeList L){ 
    int counter = 0; 
    TypeVertex v; 
    for(v=L; v->NEXT!=NULL; v = v->NEXT){ 
        counter++; 
    }
    return counter; 
}
    
//defines hash table structure as an array 
//with attributes items to be used in counting 
//how many items are in the table 
typedef struct hashTable {
   TypeList array [HashArraySize];
   int items; 
} *TypeHashTable;

//allocates memory for a new hash table 
//sets each position to an empty linked list
TypeHashTable newHashTable() {
    TypeHashTable h = (TypeHashTable) malloc(sizeof(struct hashTable));
    if (h==NULL) {printf("Malloc for a new hash table failed."); exit(1);}
    int i;
    for (i=0; i<HashArraySize; i++){
    	TypeList X = NEWVERTEX();
    	h->array[i] = X;
    }
    h->items = 0; 
    return h;
}

//function for determining whether a newly generated
//board is in the linked list at the particular 
//position in the hash table 
int isBoardInList(TypeList L, TypePuzzleBoard b) {
    TypeVertex v;
    for (v=L; v->NEXT!=NULL; v = v->NEXT){
    	if ( arePositionsEqual(v->board, b)){
    		return True;
    	}
    } 
    return False;
}


//originally used for hashing, but better hash function
//found
int primes [BoardSize]; 

//HASH function obtained by trial and error to 
//make reasonably well distributed hash table. 
//function takes in a board and multiplies 
//the character at each position by a function multiplied 
//3^i - accounts for overflow if multiplier gets too large
int HASH(TypePuzzleBoard b){
	int hashValue = 0;
	int multiplier = 1;
    int prime = 3;
	int i; 
	int j; 
	for (i=0; i<BoardHeight; i++){ 
	    for (j=0; j<BoardWidth; j++){
	        multiplier = multiplier * prime;
	        if (multiplier > 2000000000/prime){
	            multiplier = 1;
	        }
	        hashValue += (int) b->board[i][j] * multiplier;
	        hashValue = hashValue % HashArraySize; 
	    }
	}
	
	return hashValue; 
}


//inserts the board at the appropriate position in the hash 
//table, generated by the HASH function above 
void insertIntoTable(TypeHashTable h, TypePuzzleBoard b){
	int index = HASH(b) % HashArraySize;
	INSERT(b, &(h->array[index]));
	h->items++; 
}

//function that returns whether a generated board is already
//contained in the hash table 
int isInHashTable(TypeHashTable h, TypePuzzleBoard b){ 
    return isBoardInList(h->array[HASH(b)], b); 
}


//originally used in hash function to 
//test if number generated was prime
int testPrimes(int checking){
    int i; 
    for (i=checking-1; i>1; i--){
        if (checking % i == 0){ 
            return False; 
        } 
    }
    return True; 
}

//filled list of prime numbers for hash function
void fillPrimes(){
    int primesFound = 0; 
    int checking = 2; 
    while (primesFound < BoardSize) { 
        if (testPrimes(checking)){ 
            primes[primesFound] = checking; 
            primesFound++; 
        } 
        checking++; 
    }
}

//modified from class slides 
//circular queue structure that takes 
//the size of the queue from output 
//and defines a front, rear, and size 
//also has a maxSize attribute for
//generating queueStats 
typedef struct queue {
   TypePuzzleBoard array[QueueArraySize];
   int front;
   int rear;
   int size;
   int maxSize; 
} *TypeQueue;

//allocates memory for a new queue, intializes 
//stat keeping variables to zero 
TypeQueue newQueue() {
    TypeQueue q = (TypeQueue) malloc(sizeof(struct queue));
    if (q==NULL) {printf("Malloc for a new queue failed."); exit(1);}
    q->front = 0;
    q->rear = 0;
    q->size = 0;
    q->maxSize = 0; 
    int i;
    for (i=0; i<QueueArraySize; i++){
    	q->array[i] =  NULL;
    }
    return q;
}

//function for enqueuing a new board, by adding it 
//to the rear. If the rear is the size of the queue
//it wraps around to the beginning
//if the size of the queue is larger than any previously
//recorded size, this becomes the new max attribute
void Enqueue(TypePuzzleBoard b, TypeQueue q){
	if (q->size >= QueueArraySize){
		printf("QUEUE is full =(\n"); exit(1);
	}
	q->array[q->rear] = b;
	q->rear = q->rear + 1;
	if (q->rear == QueueArraySize){
		q->rear = 0;
	}
	q->size = q->size + 1;
	if (q->size > q->maxSize){ 
	    q->maxSize = q->size; 
	}
}

//takes element from front 
TypePuzzleBoard Dequeue(TypeQueue q){
	if (q->size == 0){
		printf("No solution =(\n"); exit(1);
	}
	TypePuzzleBoard temp = q->array[q->front];
	q->front = q->front + 1;
	if (q->front == QueueArraySize){
		q->front = 0;
	}
	q->size = q->size - 1;
	return temp;
}

//copies board for making a new position 
void copyBoardArray(TypePuzzleBoard b, char copy [BoardHeight][BoardWidth]){ 
    for (int i=0; i<BoardHeight; i++){ 
        for (int j=0; j<BoardWidth; j++){ 
            copy[i][j] = b -> board [i][j]; 
        }
    }
}

//converts a 2-d array to string for making new board
void boardToString(char board[BoardHeight][BoardWidth], char boardString[]){ 
    int currentPosition = 0; 
    for (int i=0; i<BoardHeight; i++){ 
        for (int j=0; j<BoardWidth; j++){ 
            boardString[currentPosition] = board[i][j]; 
            currentPosition++;
        }
    }
}   

//generates new positions. for each letter, it checks if it can be moved 
//right, left, up, and down, and if that spot does not contain a $ 
//if it can be moved, a copy of the current position is made, and 
//the elements are swapped, and the new position is queued if not in 
//hash table
void generatePositionsAndQueue(TypePuzzleBoard b, TypeHashTable h, TypeQueue q){ 
    for (int i=0; i<BoardHeight; i++){
        for (int j=0; j<BoardWidth; j++){ 
            if(b -> board [i][j] != '$' && b-> board[i][j] != '.'){
                if(j!=0 && b->board[i][j-1] == '.'){ 
                    char copy[BoardHeight][BoardWidth];
                    copyBoardArray(b, copy);
                    int temp =  copy[i][j-1]; 
                    copy[i][j-1] = copy[i][j]; 
                    copy[i][j] = temp; 
                    char boardString[BoardSize+1]; 
                    boardToString(copy, boardString);                
                    TypePuzzleBoard newBoard = newPuzzleBoard(boardString);
                    newBoard->numRounds = b->numRounds+1;
                    newBoard->prev = b;
                    newBoard->dir = 3;
                    newBoard->pieceMoved = b->board[i][j];
                    if (!(isInHashTable(h, newBoard))) {
                        insertIntoTable(h, newBoard); 
                        Enqueue(newBoard, q); 
                    }
                }
                
                if(j!=BoardWidth-1 && b->board[i][j+1] == '.'){ 
                    char copy[BoardHeight][BoardWidth];
                    copyBoardArray(b, copy);
                    int temp =  copy[i][j+1]; 
                    copy[i][j+1] = copy[i][j]; 
                    copy[i][j] = temp; 
                    char boardString[BoardSize+1]; 
                    boardToString(copy, boardString);                
                    TypePuzzleBoard newBoard = newPuzzleBoard(boardString);
                    newBoard->numRounds = b->numRounds+1;
                    newBoard->prev = b;
                    newBoard->dir = 1;
                    newBoard->pieceMoved = b->board[i][j];
                    if (!(isInHashTable(h, newBoard))) {
                        insertIntoTable(h, newBoard); 
                        Enqueue(newBoard, q); 
                    }
                }
                
                if(i!=0 && b->board[i-1][j] == '.'){ 
                    char copy[BoardHeight][BoardWidth];
                    copyBoardArray(b, copy);
                    int temp =  copy[i-1][j]; 
                    copy[i-1][j] = copy[i][j]; 
                    copy[i][j] = temp; 
                    char boardString[BoardSize+1]; 
                    boardToString(copy, boardString);                
                    TypePuzzleBoard newBoard = newPuzzleBoard(boardString);
                    newBoard->numRounds = b->numRounds+1;
                    newBoard->prev = b;
                    newBoard->dir = 0;
                    newBoard->pieceMoved = b->board[i][j];
                    if (!(isInHashTable(h, newBoard))) {
                        insertIntoTable(h, newBoard); 
                        Enqueue(newBoard, q); 
                    }
                }
                
                if(i!=BoardHeight-1 && b->board[i+1][j] == '.'){ 
                    char copy[BoardHeight][BoardWidth];
                    copyBoardArray(b, copy);
                    int temp =  copy[i+1][j]; 
                    copy[i+1][j] = copy[i][j]; 
                    copy[i][j] = temp; 
                    char boardString[BoardSize+1]; 
                    boardToString(copy, boardString);                
                    TypePuzzleBoard newBoard = newPuzzleBoard(boardString);
                    newBoard->numRounds = b->numRounds+1;
                    newBoard->prev = b;
                    newBoard->dir = 2;
                    newBoard->pieceMoved = b->board[i][j];
                    if (!(isInHashTable(h, newBoard))) {
                        insertIntoTable(h, newBoard); 
                        Enqueue(newBoard, q);
                    }
                }
                
            }
        }
    }
}


int main() {
    
    //intializes 
    TypePuzzleBoard start= newPuzzleBoard(StartBoard); 
    TypePuzzleBoard end = newPuzzleBoard(GoalBoard); 
    TypePuzzleBoard lastBoard;
    TypeQueue q = newQueue();
    TypeHashTable h = newHashTable();
    
    Enqueue(start, q); 
    
    insertIntoTable(h, start); 
    
    int found = False;  
    while(found == False){
        TypePuzzleBoard newBoard = Dequeue(q); //next board
        if(arePositionsEqual(newBoard, end)){ 
            found = True; 
            lastBoard = newBoard;
        } else {
            generatePositionsAndQueue(newBoard, h, q); 
        } 
    }
    

    //reverses pointers for printing solution
    TypePuzzleBoard last = NULL;
    while (lastBoard!=NULL){
        TypePuzzleBoard temp = lastBoard -> prev; 
        lastBoard -> prev = last; 
        last = lastBoard;
        lastBoard = temp;
    }
    lastBoard = last;
    
    //prints each step
    int step = 0;
    while (lastBoard!=NULL){
        char boardString[BoardSize+1]; 
        boardToString(lastBoard->board, boardString);
        OutputPosition(boardString, step++, lastBoard->pieceMoved, lastBoard->dir);
        lastBoard = lastBoard->prev;
    }
    
    //prints queue statistics 
    QueueStats(QueueArraySize, q->maxSize, q->front, q->rear); 
    printf("\n"); 
    
    //defines max bucket size of hash tabe, intializes 
    //array to keep track of how many buckets of a particular 
    //size 
    int maxBucketSize = 0;
    int hashStats[HashStatsMAX]; 
    for (int i =0; i<HashStatsMAX; i++){
        hashStats[i]=0;
    }
    
    //collects data on hash function
    for(int i=0; i<HashArraySize; i++){ 
        int len = lengthOfLinkedList(h->array[i]);
        if(len>maxBucketSize){
            maxBucketSize = len; 
        }
        if(len<HashStatsMAX){ 
            hashStats[len]++;
        }
    }
    
    
    //prints hash statistics for each bucket size, 
    //if the bucket size is less than the max hash 
    //stats, only prints bucket size to that bucket size 
    HashStats(HashArraySize, h->items, maxBucketSize); 
    int maxCount;
    if (maxBucketSize < HashStatsMAX){
        maxCount = maxBucketSize+1;
    }
    else{
        maxCount = HashStatsMAX;
    }
    for(int i=0; i<maxCount; i++){ 
        BucketStat(i, hashStats[i]); 
    }
    
    
	return 0; 
}

